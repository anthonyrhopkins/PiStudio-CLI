#!/usr/bin/env bash
#
# pistudio - Human-friendly CLI for Copilot Studio
#
# Thin wrapper that translates subcommands into --flag syntax
# for scripts/export-activities.sh. Zero modifications to the monolith.
#
# Usage: pistudio <command> [subcommand] [options]
#        pistudio --flag args...   (passthrough to export-activities.sh)
#

set -euo pipefail

# ─── Script resolution ─────────────────────────────────────────
_PISTUDIO_SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$_PISTUDIO_SOURCE" ]]; do
    _PISTUDIO_SOURCE="$(readlink "$_PISTUDIO_SOURCE")"
done
SELF="$(cd "$(dirname "$_PISTUDIO_SOURCE")" && pwd)"
EXPORT_SCRIPT="${PISTUDIO_EXPORT_SCRIPT:-${SELF}/../scripts/export-activities.sh}"
CONFIG_FILE="${PISTUDIO_CONFIG_FILE:-${SELF}/../config/copilot-export.json}"

# Source shared auth module
# shellcheck disable=SC1091
source "${SELF}/../scripts/auth.sh"

if [[ ! -x "$EXPORT_SCRIPT" ]]; then
    echo "error: export-activities.sh not found at $EXPORT_SCRIPT" >&2
    exit 1
fi

DRY_RUN=false
DEVICE_CODE=false
VERBOSE=false
GLOBAL_ARGS=()
PROD_ACK=false
AUDIT_LOG_FILE="${SELF}/../logs/audit/operations.jsonl"

# ─── Colors ─────────────────────────────────────────────────────
BOLD=$'\033[1m'
DIM=$'\033[2m'
CYAN=$'\033[0;36m'
YELLOW=$'\033[1;33m'
NC=$'\033[0m'

# ─── Tiered help ────────────────────────────────────────────────

help_brief() {
    cat <<EOF
${BOLD}Copilot Studio CLI${NC}

${BOLD}Usage:${NC} pistudio <command> [subcommand] [options]

${BOLD}Commands:${NC}
  login          Authenticate via browser SSO (--device-code for manual flow)
  logout         Sign out
  status         Show auth status and current profile
  doctor         Run preflight checks (auth, tenant, env, APIs)
  envs           List Power Platform environments
  copilot        Copilot commands (list, get, create, remove, restore)
  bots           List Copilot Studio bots
  agents         Manage sub-agents (list, get, create, update, delete, ...)
  convs          Conversations (list, export, search, watch)
  transcripts    Dataverse transcripts (list, export)
  open           Open in Copilot Studio browser
  analytics      Regenerate analytics from existing export

${BOLD}Shortcuts:${NC}
  export <id>    Export conversation (alias for convs export)
  search <term>  Search conversations (alias for convs search)
  watch <id>     Watch conversation (alias for convs watch)

${BOLD}Global flags:${NC}
  -p, --profile <name>   Config profile (e.g. dev, prod)
  -b, --bot-id <name>    Bot schema name
  -v, --verbose          Debug output
  --debug                Debug output (M365-compatible)
  -o, --output <value>   For exports: output directory (report folder)
                         For copilot: M365 output format (json|text|csv|md|none)
  --dry-run              Print translated command without executing
  --i-know-this-is-prod  Allow writes for protected profiles (prod)
  --help                 Full reference (delegates to export-activities.sh)

Run ${DIM}pistudio <command> --help${NC} for command details.
EOF
}

help_doctor() {
    cat <<EOF
${BOLD}pistudio doctor${NC} — Preflight checks

Checks:
  - Required tools: jq, curl
  - Stored refresh token for active profile
  - Active identity + tenant
  - Profile config completeness (tenantId, environmentId, dataverseUrl, botId)
  - Tenant safety (active tenant matches profile tenant)

Usage:
  pistudio doctor
  pistudio doctor -p <profile>

EOF
}

help_envs() {
    cat <<EOF
${BOLD}pistudio envs${NC} — Power Platform environments

${BOLD}Usage:${NC}
  pistudio envs                       List all environments
  pistudio envs details <env-id>      Show environment details
  pistudio envs flags <env-id>        Show feature flags

${BOLD}Examples:${NC}
  pistudio envs
  pistudio envs details <env-id>
  pistudio envs flags <env-id>
EOF
}

help_bots() {
    cat <<EOF
${BOLD}pistudio bots${NC} — Copilot Studio bots

${BOLD}Usage:${NC}
  pistudio bots                       List all bots
  pistudio bots -p <profile>          List bots for a profile

${BOLD}Examples:${NC}
  pistudio bots
  pistudio bots -p prod
EOF
}

help_copilot() {
    cat <<EOF
${BOLD}pistudio copilot${NC} — Copilot commands (via Dataverse API)

${BOLD}Usage:${NC}
  pistudio copilot list [options]
  pistudio copilot get --id <id>|--name <name> [options]
  pistudio copilot create --name <name> [--schema <schema>] [options]
  pistudio copilot remove --id <id>|--name <name> --yes-really-delete --confirm <name|id> [options]
  pistudio copilot restore --from-backup <dir> --name <name> [--schema <schema>] [options]

${BOLD}Options:${NC}
  -p, --profile <name>                  Use profile to resolve environment
  -e, --env-id <environment-id>         Environment ID/name
  --as-admin                             Run as admin (maps to --asAdmin)
  --name <name>                          Copilot name (create/restore/remove/get)
  --schema <schema>                      Copilot schema name (create/restore)
  --from-backup <dir>                    Backup directory for one-command restore
  --yes-really-delete                    Required safety confirmation for remove
  --confirm <exact name|id>              Must match target copilot name or id
  --i-know-this-is-prod                  Required for protected profiles (for writes)
  --query <JMESPath>                     Filter output
  -o, --output <json|text|csv|md|none>  Output type

${BOLD}Examples:${NC}
  pistudio copilot list -p dev -o json
  pistudio copilot get --name "My Copilot" -p dev
  pistudio copilot create --name "Research Agent" --schema my_research_agent -p dev
  pistudio copilot remove --name "Old Agent" --yes-really-delete --confirm "Old Agent" -p dev
  pistudio copilot restore --from-backup ./backups/agents_20260123 --name "My Agent" -p dev
EOF
}

help_agents() {
    cat <<EOF
${BOLD}pistudio agents${NC} — Sub-agent management

${BOLD}Usage:${NC}
  pistudio agents                                 List sub-agents
  pistudio agents get <name|schema>               Export agent config to YAML
  pistudio agents create <name> -b <bot> [opts]   Create new agent
  pistudio agents update <schema> --field F --value V  Update agent field
  pistudio agents delete <schema> --yes-really-delete --confirm <name|schema>  Delete agent (auto-backup)
  pistudio agents clone <schema> --name <name>    Clone agent
  pistudio agents diff <schema-a> <schema-b>      Compare two agents
  pistudio agents backup [-b <bot>]               Backup all agents
  pistudio agents restore --dir <path> -b <bot>   Restore from backup

${BOLD}Create/Update options:${NC}
  --yaml-file <path>    YAML config file
  --field <field>       Field to update (data, description, name)
  --value <value>       New value (string or file path for data)
  --yes-really-delete   Required safety confirmation for delete
  --confirm <value>     Must match exact agent name or schema
  --i-know-this-is-prod Required for protected profiles (for writes)

${BOLD}Examples:${NC}
  pistudio agents -p dev
  pistudio agents get 'My Agent' -p dev
  pistudio agents create 'Research Bot' -b my_bot --yaml-file ./config.yaml
  pistudio agents update my_bot.agent.Agent_Abc --field data --value ./config.yaml
  pistudio agents clone my_bot.agent.Agent_Abc --name 'Agent Copy'
  pistudio agents diff my_bot.agent.Agent_A my_bot.agent.Agent_B
  pistudio agents backup -b my_bot
  pistudio agents delete my_bot.agent.Agent_Abc --yes-really-delete --confirm my_bot.agent.Agent_Abc
EOF
}

help_convs() {
    cat <<EOF
${BOLD}pistudio convs${NC} — Conversations

${BOLD}Usage:${NC}
  pistudio convs                                  List conversations
  pistudio convs export <id> [--days N]           Export conversation
  pistudio convs export --all --file <path>       Export all from file
  pistudio convs search <term> [--days N]         Search conversations
  pistudio convs watch <id> [--interval N]        Watch live conversation

${BOLD}Options:${NC}
  -d, --days <N>         Filter to last N days
  --interval <seconds>   Watch polling interval (default: 5)

${BOLD}Examples:${NC}
  pistudio convs -p dev
  pistudio convs export <conv-id>
  pistudio convs export '<id1>,<id2>' --days 7
  pistudio convs search 'error message'
  pistudio convs watch <conv-id>
EOF
}

help_transcripts() {
    cat <<EOF
${BOLD}pistudio transcripts${NC} — Dataverse transcripts

${BOLD}Usage:${NC}
  pistudio transcripts                            List transcripts
  pistudio transcripts export <id>                Export transcript by ID
  pistudio transcripts export --bot-guid <guid>   Export by bot GUID

${BOLD}Examples:${NC}
  pistudio transcripts -p prod
  pistudio transcripts export <transcript-id> -p prod
  pistudio transcripts export --bot-guid <bot-guid> -p prod
EOF
}

# ─── Fuzzy matching ─────────────────────────────────────────────

COMMANDS=(login logout status doctor envs copilot bots agents convs transcripts open analytics export search watch)

# Character overlap score (0-100)
char_overlap() {
    local input="$1" candidate="$2"
    local -i matches=0 len=${#input}
    [[ $len -eq 0 ]] && echo 0 && return
    local remaining="$candidate"
    for (( i=0; i<len; i++ )); do
        local ch="${input:$i:1}"
        if [[ "$remaining" == *"$ch"* ]]; then
            (( matches++ ))
            # Remove first occurrence
            remaining="${remaining/$ch/}"
        fi
    done
    echo $(( matches * 100 / len ))
}

fuzzy_match() {
    local input="$1"
    local best="" best_score=0

    for cmd in "${COMMANDS[@]}"; do
        # Exact prefix match
        if [[ "$cmd" == "$input"* ]]; then
            echo "$cmd"
            return 0
        fi
        # Substring match
        if [[ "$cmd" == *"$input"* ]]; then
            echo "$cmd"
            return 0
        fi
    done

    # Character overlap scoring
    for cmd in "${COMMANDS[@]}"; do
        local score
        score=$(char_overlap "$input" "$cmd")
        if (( score > best_score )); then
            best_score=$score
            best="$cmd"
        fi
    done

    if (( best_score > 50 )); then
        echo "$best"
        return 0
    fi
    return 1
}

unknown_command() {
    local input="$1"
    echo -e "pistudio: ${BOLD}'$input'${NC} is not a command." >&2
    echo "" >&2
    local suggestion
    if suggestion=$(fuzzy_match "$input"); then
        echo -e "Did you mean?" >&2
        echo -e "    ${CYAN}$suggestion${NC}" >&2
        echo "" >&2
    fi
    echo "Run 'pistudio --help' for a list of commands." >&2
    exit 1
}

suggest_verb() {
    local noun="$1" verb="$2"
    local -a valid_verbs=()
    case "$noun" in
        copilot) valid_verbs=(list get create remove restore) ;;
        agents) valid_verbs=(get create update delete clone diff backup restore) ;;
        convs)  valid_verbs=(export search watch) ;;
        transcripts) valid_verbs=(export) ;;
        envs)   valid_verbs=(details flags) ;;
        *)      valid_verbs=() ;;
    esac

    echo -e "pistudio: ${BOLD}'$verb'${NC} is not a valid ${noun} subcommand." >&2
    if [[ ${#valid_verbs[@]} -gt 0 ]]; then
        echo "" >&2
        echo "Available subcommands:" >&2
        for v in "${valid_verbs[@]}"; do
            echo -e "    ${CYAN}$v${NC}" >&2
        done
        echo "" >&2
    fi
    echo "Run 'pistudio $noun --help' for details." >&2
    exit 1
}

# ─── Execute or dry-run ────────────────────────────────────────

run() {
    if [[ "$DRY_RUN" == true ]]; then
        echo "scripts/export-activities.sh $*"
    else
        "$EXPORT_SCRIPT" "$@"
    fi
}

require_option_value() {
    local flag="$1" value="${2-}"
    if [[ -z "$value" || "$value" == -* ]]; then
        echo "error: $flag requires a value" >&2
        exit 1
    fi
}

run_with_timeout() {
    local seconds="$1"
    shift

    if command -v timeout &>/dev/null; then
        timeout "$seconds" "$@"
    elif command -v gtimeout &>/dev/null; then
        gtimeout "$seconds" "$@"
    else
        "$@"
    fi
}

# ─── Safety, Auth & Audit ──────────────────────────────────────

now_iso_utc() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

require_jq() {
    if ! command -v jq &>/dev/null; then
        echo "error: jq is required. Install: brew install jq (macOS) or apt-get install jq (Linux)" >&2
        exit 1
    fi
}

is_protected_profile() {
    local profile="$1"
    [[ -z "$profile" ]] && return 1

    # Convention: profile key or profile name contains prod/production; or explicit config flags.
    local pname protected is_prod
    pname=$(read_profile_field "$profile" "name" || true)
    protected=$(read_profile_field "$profile" "protected" || true)
    is_prod=$(read_profile_field "$profile" "isProd" || true)

    if [[ "$profile" =~ [Pp][Rr][Oo][Dd] ]] || [[ "$pname" =~ [Pp][Rr][Oo][Dd] ]] || [[ "$pname" =~ [Pp]roduction ]]; then
        return 0
    fi
    if [[ "$protected" == "true" ]] || [[ "$is_prod" == "true" ]]; then
        return 0
    fi
    return 1
}

require_write_allowed() {
    local op="$1"
    local profile
    profile=$(resolve_profile)
    if [[ -z "$profile" ]]; then
        echo "error: $op requires --profile <name> (to enforce tenant safety + resolve Dataverse URL)" >&2
        exit 1
    fi

    export PISTUDIO_ACTIVE_PROFILE="$profile"
    PISTUDIO_PROFILE_TENANT_ID="$(read_profile_field "$profile" "tenantId" 2>/dev/null || true)"
    export PISTUDIO_PROFILE_TENANT_ID

    if is_protected_profile "$profile" && [[ "$PROD_ACK" != true ]]; then
        echo "error: $op is blocked for protected profile '$profile' without --i-know-this-is-prod" >&2
        exit 1
    fi

    local profile_tenant
    profile_tenant=$(read_profile_field "$profile" "tenantId" || true)
    if [[ -n "$profile_tenant" ]]; then
        local active_tenant
        active_tenant=$(get_active_tenant_id)
        if [[ -z "$active_tenant" ]]; then
            echo "error: cannot determine active tenant. Run 'pistudio login -p $profile'." >&2
            exit 1
        fi
        if [[ "$active_tenant" != "$profile_tenant" ]]; then
            echo "error: tenant mismatch. Active tenant is '$active_tenant' but profile '$profile' expects '$profile_tenant'." >&2
            echo "hint: run 'pistudio login -p $profile'." >&2
            exit 1
        fi
    fi
}

audit_log() {
    # Usage: audit_log <operation> <exit_code> <cmdline> [backup_dir]
    local operation="$1"
    local exit_code="$2"
    local cmdline="$3"
    local backup_dir="${4:-}"

    mkdir -p "$(dirname "$AUDIT_LOG_FILE")" 2>/dev/null || true

    if ! command -v jq &>/dev/null; then
        return 0
    fi

    local profile env_name actor tenant_id
    profile=$(resolve_profile || true)
    export PISTUDIO_ACTIVE_PROFILE="${profile:-default}"
    PISTUDIO_PROFILE_TENANT_ID="$(read_profile_field "${profile:-default}" "tenantId" 2>/dev/null || true)"
    export PISTUDIO_PROFILE_TENANT_ID
    env_name=$(resolve_env_name || true)
    actor=$(get_active_user || true)
    tenant_id=$(get_active_tenant_id || true)

    jq -n \
        --arg ts "$(now_iso_utc)" \
        --arg op "$operation" \
        --arg actor "$actor" \
        --arg tenantId "$tenant_id" \
        --arg profile "$profile" \
        --arg env "$env_name" \
        --arg cmd "$cmdline" \
        --arg backupDir "$backup_dir" \
        --argjson dryRun "$( [[ "$DRY_RUN" == true ]] && echo true || echo false )" \
        --argjson exitCode "$exit_code" \
        '{ts:$ts, operation:$op, actor:$actor, tenantId:$tenantId, profile:$profile, environment:$env, dryRun:$dryRun, exitCode:$exitCode, cmd:$cmd, backupDir: ($backupDir | select(length>0) )}' \
        >> "$AUDIT_LOG_FILE" 2>/dev/null || true
}

require_profile_dataverse_url() {
    local profile="$1"
    local dv_url
    dv_url=$(read_profile_field "$profile" "dataverseUrl" || true)
    if [[ -z "$dv_url" ]]; then
        echo "error: profile '$profile' is missing 'dataverseUrl' in $CONFIG_FILE" >&2
        exit 1
    fi
}

dataverse_get_bot_by_schema() {
    local dv_url="$1"
    local schema="$2"
    require_jq
    local token
    token=$(get_access_token "$dv_url") || return 1
    curl -s "${dv_url}/api/data/v9.2/bots?\$select=botid,name,schemaname,statecode,statuscode,createdon,modifiedon&\$filter=schemaname%20eq%20'${schema}'" \
        -H "Authorization: Bearer $token" \
        -H "OData-MaxVersion: 4.0" \
        -H "Accept: application/json"
}

dataverse_create_bot() {
    local dv_url="$1"
    local name="$2"
    local schema="$3"
    require_jq

    local token
    token=$(get_access_token "$dv_url") || return 1

    local config payload
    config=$(jq -n --arg s "$schema" '{\"$kind\":\"BotConfiguration\",\"settings\":{\"GenerativeActionsEnabled\":true},\"isAgentConnectable\":true,\"gPTSettings\":{\"$kind\":\"GPTSettings\",\"defaultSchemaName\":($s+\".gpt.default\")},\"aISettings\":{\"$kind\":\"AISettings\",\"useModelKnowledge\":false,\"isFileAnalysisEnabled\":false,\"isSemanticSearchEnabled\":true,\"contentModeration\":\"Low\",\"optInUseLatestModels\":true},\"recognizer\":{\"$kind\":\"GenerativeAIRecognizer\"}}' | jq -c .)
    payload=$(jq -n --arg name "$name" --arg schema "$schema" --arg config "$config" '{name:$name, schemaname:$schema, language:1033, authenticationtrigger:1, configuration:$config}')

    local code
    code=$(curl -s -o /tmp/pistudio_create_bot.json -w "%{http_code}" -X POST "${dv_url}/api/data/v9.2/bots" \
        -H "Authorization: Bearer $token" \
        -H "OData-MaxVersion: 4.0" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        -d "$payload")

    if [[ "$code" != "204" && "$code" != "201" ]]; then
        cat /tmp/pistudio_create_bot.json >&2 || true
        return 1
    fi
    return 0
}

dataverse_call_bot_action() {
    local dv_url="$1"
    local bot_id="$2"
    local action="$3" # PvaProvision, PvaPublish, ...
    require_jq

    local token
    token=$(get_access_token "$dv_url") || return 1

    local code
    code=$(curl -s -o /tmp/pistudio_bot_action.json -w "%{http_code}" -X POST "${dv_url}/api/data/v9.2/bots(${bot_id})/Microsoft.Dynamics.CRM.${action}" \
        -H "Authorization: Bearer $token" \
        -H "OData-MaxVersion: 4.0" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        -d '{}')
    if [[ "$code" != "204" && "$code" != "200" && "$code" != "202" ]]; then
        cat /tmp/pistudio_bot_action.json >&2 || true
        return 1
    fi
    return 0
}

dataverse_get_botcomponent_by_schema() {
    local dv_url="$1"
    local schema="$2"
    require_jq
    local token
    token=$(get_access_token "$dv_url") || return 1
    curl -s "${dv_url}/api/data/v9.2/botcomponents?\$select=name,schemaname,botcomponentid,description,data,createdon,modifiedon&\$filter=schemaname%20eq%20'${schema}'" \
        -H "Authorization: Bearer $token" \
        -H "OData-MaxVersion: 4.0" \
        -H "Accept: application/json"
}

dataverse_delete_botcomponent_by_id() {
    local dv_url="$1"
    local component_id="$2"
    require_jq
    local token
    token=$(get_access_token "$dv_url") || return 1
    local code
    code=$(curl -s -o /tmp/pistudio_delete_component.json -w "%{http_code}" -X DELETE "${dv_url}/api/data/v9.2/botcomponents(${component_id})" \
        -H "Authorization: Bearer $token" \
        -H "OData-MaxVersion: 4.0" \
        -H "Accept: application/json")
    if [[ "$code" != "204" ]]; then
        cat /tmp/pistudio_delete_component.json >&2 || true
        return 1
    fi
    return 0
}

safe_fs_component() {
    # Convert arbitrary string to a safe filename-ish component.
    local s="$1"
    s="${s// /_}"
    s=$(echo "$s" | tr -cd '[:alnum:]_.-')
    [[ -z "$s" ]] && s="item"
    echo "$s"
}

derive_schema_from_name() {
    local name="$1"
    local s
    s=$(echo "$name" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' '_' | sed 's/^_\\+//; s/_\\+$//' | sed 's/__\\+/_/g')
    if [[ -z "$s" ]]; then
        echo ""
        return 1
    fi
    # Dataverse schema names must be alnum/underscore and ideally start with a letter.
    if [[ ! "$s" =~ ^[a-z] ]]; then
        s="bot_${s}"
    fi
    # Keep it reasonably short.
    echo "${s:0:60}"
}

# ─── Extract global flags from args ────────────────────────────
# Pulls --dry-run, -p/--profile, -v/--verbose, -b/--bot-id out of
# positional args so they can be forwarded after translation.

extract_globals() {
    local -a remaining=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --device-code)
                DEVICE_CODE=true
                shift
                ;;
            -p|--profile)
                require_option_value "$1" "${2-}"
                GLOBAL_ARGS+=(--profile "$2")
                shift 2
                ;;
            -b|--bot-id)
                require_option_value "$1" "${2-}"
                GLOBAL_ARGS+=(-b "$2")
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                GLOBAL_ARGS+=(-v)
                shift
                ;;
            --debug)
                GLOBAL_ARGS+=(--debug)
                shift
                ;;
            --i-know-this-is-prod)
                PROD_ACK=true
                shift
                ;;
            -d|--days)
                require_option_value "$1" "${2-}"
                GLOBAL_ARGS+=(--days "$2")
                shift 2
                ;;
            -o|--output)
                require_option_value "$1" "${2-}"
                GLOBAL_ARGS+=(-o "$2")
                shift 2
                ;;
            *)
                remaining+=("$1")
                shift
                ;;
        esac
    done
    POSITIONAL=("${remaining[@]+"${remaining[@]}"}")
}

# ─── Auth commands (via auth.sh device code flow) ─────────────

# Read a profile field from config JSON
read_profile_field() {
    local profile="$1" field="$2"
    if [[ -f "$CONFIG_FILE" ]] && command -v jq &>/dev/null; then
        local value
        value=$(jq -r --arg p "$profile" --arg f "$field" \
            '.profiles[$p][$f] // empty' "$CONFIG_FILE" 2>/dev/null)
        [[ -n "$value" ]] && echo "$value"
    fi
}

# Resolve which profile to use (explicit > default > none)
resolve_profile() {
    local explicit=""
    for arg in "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"; do
        if [[ "$arg" == "--profile" ]]; then
            explicit="__next__"
        elif [[ "$explicit" == "__next__" ]]; then
            echo "$arg"
            return
        fi
    done
    # Fall back to defaultProfile in config
    if [[ -f "$CONFIG_FILE" ]] && command -v jq &>/dev/null; then
        jq -r '.defaultProfile // empty' "$CONFIG_FILE" 2>/dev/null
    fi
}

resolve_env_name() {
    local env_name=""

    local profile
    profile=$(resolve_profile)
    if [[ -n "$profile" ]]; then
        env_name=$(read_profile_field "$profile" "environmentId")
    fi

    if [[ -z "$env_name" ]]; then
        env_name="${COPILOT_ENV_ID:-}"
    fi

    if [[ -z "$env_name" ]]; then
        local env_url="${COPILOT_ENV_URL:-}"
        if [[ "$env_url" =~ ^https://([^.]+)\.environment\.api\.powerplatform\.com/?$ ]]; then
            env_name="${BASH_REMATCH[1]}"
        fi
    fi

    echo "$env_name"
}

cmd_login() {
    local profile tenant_id profile_name user

    profile=$(resolve_profile)

    if [[ -n "$profile" ]]; then
        tenant_id=$(read_profile_field "$profile" "tenantId")
        profile_name=$(read_profile_field "$profile" "name")
        user=$(read_profile_field "$profile" "user")
    fi

    local login_fn="pistudio_login_browser"
    if [[ "$DEVICE_CODE" == true ]]; then
        login_fn="pistudio_login"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        echo "$login_fn \"${profile:-default}\" \"${tenant_id:-common}\" \"${user:-}\""
        return 0
    fi

    if [[ -n "$tenant_id" ]]; then
        echo -e "${CYAN}Logging in to ${BOLD}${profile_name:-$profile}${NC}${CYAN} (${user:-})${NC}"
        echo -e "${DIM}Tenant: ${tenant_id}${NC}"
        if [[ "$DEVICE_CODE" == true ]]; then
            echo -e "${DIM}Mode: device code${NC}"
        else
            echo -e "${DIM}Mode: browser SSO${NC}"
        fi
        echo ""
    else
        echo -e "${CYAN}Logging in...${NC}"
        echo ""
    fi

    "$login_fn" "${profile:-default}" "${tenant_id:-common}" "${user:-}"
}

cmd_logout() {
    local profile
    profile=$(resolve_profile)

    if [[ "$DRY_RUN" == true ]]; then
        echo "pistudio_logout \"${profile:-default}\""
        return 0
    fi

    pistudio_logout "${profile:-default}"
}

cmd_status() {
    local profile profile_name user tenant_id env_name bot_name

    profile=$(resolve_profile)
    export PISTUDIO_ACTIVE_PROFILE="${profile:-default}"
    PISTUDIO_PROFILE_TENANT_ID="$(read_profile_field "${profile:-default}" "tenantId" 2>/dev/null || true)"
    export PISTUDIO_PROFILE_TENANT_ID

    echo -e "${BOLD}Copilot Studio CLI${NC}"
    echo ""

    # Auth status
    echo -e "${BOLD}Auth:${NC}"
    if [[ "$DRY_RUN" == true ]]; then
        echo "pistudio_status \"${profile:-default}\""
    else
        local auth_json
        auth_json=$(pistudio_status "${profile:-default}")
        local logged_in connected_as auth_tenant
        logged_in=$(printf '%s' "$auth_json" | jq -r '.logged_in')
        connected_as=$(printf '%s' "$auth_json" | jq -r '.connectedAs // empty')
        auth_tenant=$(printf '%s' "$auth_json" | jq -r '.tenantId // empty')

        if [[ "$logged_in" == "true" ]]; then
            echo -e "  ${BOLD}Logged in${NC} as ${connected_as:-unknown}"
            [[ -n "$auth_tenant" ]] && echo -e "  Tenant: ${auth_tenant}"
        else
            echo -e "  Not logged in. Run ${DIM}pistudio login${NC}"
        fi
    fi

    # Profile info
    if [[ -n "$profile" ]]; then
        profile_name=$(read_profile_field "$profile" "name")
        user=$(read_profile_field "$profile" "user")
        tenant_id=$(read_profile_field "$profile" "tenantId")
        env_name=$(read_profile_field "$profile" "environmentId")
        bot_name=$(read_profile_field "$profile" "botName")

        echo ""
        echo -e "${BOLD}Profile:${NC} ${profile} ${DIM}(${profile_name:-})${NC}"
        [[ -n "$user" ]] && echo -e "  User:        ${user}"
        [[ -n "$tenant_id" ]] && echo -e "  Tenant:      ${tenant_id}"
        [[ -n "$env_name" ]] && echo -e "  Environment: ${env_name}"
        [[ -n "$bot_name" ]] && echo -e "  Bot:         ${bot_name}"
    fi

    # Sources (verbose only)
    if [[ "$VERBOSE" == true ]]; then
        local token_file repo_dir
        token_file=$(_pistudio_token_file "${profile:-default}")
        repo_dir="$(cd "${SELF}/.." && pwd)"
        echo ""
        echo -e "${BOLD}Sources:${NC}"
        echo -e "  Config:  ${repo_dir}/config/copilot-export.json"
        echo -e "  Tokens:  ${token_file}"
        echo -e "  Script:  ${repo_dir}/scripts/export-activities.sh"
        echo -e "  Auth:    ${repo_dir}/scripts/auth.sh"
    fi

    # List available profiles
    if [[ -f "$CONFIG_FILE" ]] && command -v jq &>/dev/null; then
        local profiles
        profiles=$(jq -r '.profiles | keys[]' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$profiles" ]]; then
            echo ""
            echo -e "${BOLD}Available profiles:${NC}"
            while IFS= read -r p; do
                local pname
                pname=$(read_profile_field "$p" "name")
                if [[ "$p" == "$profile" ]]; then
                    echo -e "  ${CYAN}* ${p}${NC} ${DIM}(${pname})${NC}"
                else
                    echo -e "    ${p} ${DIM}(${pname})${NC}"
                fi
            done <<< "$profiles"
        fi
    fi
}

cmd_doctor() {
    local profile
    profile=$(resolve_profile || true)
    export PISTUDIO_ACTIVE_PROFILE="${profile:-default}"
    PISTUDIO_PROFILE_TENANT_ID="$(read_profile_field "${profile:-default}" "tenantId" 2>/dev/null || true)"
    export PISTUDIO_PROFILE_TENANT_ID

    echo -e "${BOLD}Copilot Studio CLI Doctor${NC}"
    echo ""
    echo -e "${BOLD}Config:${NC} $CONFIG_FILE"
    [[ -n "$profile" ]] && echo -e "${BOLD}Profile:${NC} $profile"
    echo ""

    local ok=true

    # Tools (only jq and curl are required)
    echo -e "${BOLD}Tools:${NC}"
    for tool in jq curl; do
        if command -v "$tool" &>/dev/null; then
            echo "  - $tool: ok"
        else
            echo "  - $tool: MISSING"
            ok=false
        fi
    done

    # Check for refresh token
    echo ""
    echo -e "${BOLD}Auth:${NC}"
    if pistudio_has_valid_token "${profile:-default}"; then
        echo "  - refresh token: ok"
    else
        echo "  - refresh token: MISSING (run 'pistudio login')"
        ok=false
    fi

    if command -v jq &>/dev/null; then
        local actor tenant
        actor=$(get_active_user || true)
        tenant=$(get_active_tenant_id || true)
        echo -e "${BOLD}Identity:${NC}"
        echo "  - user:   ${actor}"
        echo "  - tenant: ${tenant:-unknown}"
        echo ""

        if [[ -n "$profile" ]]; then
            echo -e "${BOLD}Profile Fields:${NC}"
            local tenant_id env_id dv_url bot_id
            tenant_id=$(read_profile_field "$profile" "tenantId" || true)
            env_id=$(read_profile_field "$profile" "environmentId" || true)
            dv_url=$(read_profile_field "$profile" "dataverseUrl" || true)
            bot_id=$(read_profile_field "$profile" "botId" || true)

            if [[ -n "$tenant_id" ]]; then echo "  - tenantId:      $tenant_id"; else echo "  - tenantId:      MISSING"; ok=false; fi
            if [[ -n "$env_id" ]]; then echo "  - environmentId: $env_id"; else echo "  - environmentId: MISSING"; ok=false; fi
            if [[ -n "$dv_url" ]]; then echo "  - dataverseUrl:  $dv_url"; else echo "  - dataverseUrl:  MISSING"; ok=false; fi
            if [[ -n "$bot_id" ]]; then echo "  - botId:         $bot_id"; else echo "  - botId:         MISSING"; ok=false; fi

            if is_protected_profile "$profile"; then
                echo "  - protected:     true (writes require --i-know-this-is-prod)"
            else
                echo "  - protected:     false"
            fi

            echo ""
            if [[ -n "$tenant_id" && -n "$tenant" && "$tenant" != "$tenant_id" ]]; then
                echo "  - tenant safety: FAIL (active tenant != profile tenant)"
                ok=false
            elif [[ -n "$tenant_id" && -n "$tenant" ]]; then
                echo "  - tenant safety: ok"
            else
                echo "  - tenant safety: unknown (no active tenant detected)"
            fi
        fi
    fi

    echo ""
    if [[ "$ok" == true ]]; then
        echo "Doctor result: ok"
        return 0
    fi
    echo "Doctor result: FAIL"
    return 1
}

cmd_copilot() {
    local verb="${1:-}"
    case "$verb" in
        ""|list|get|create|remove|restore)
            ;;
        --help|-h)
            help_copilot
            return
            ;;
        *)
            suggest_verb copilot "$verb"
            ;;
    esac

    local subcommand="${verb:-list}"

    local env_name=""
    local has_env=false

    local remove_confirmed=false
    local confirm_value=""
    local target_id=""
    local target_name=""

    local schema_arg=""
    local backup_dir=""

    local -a selector_args=()
    local -a pass_args=()
    local -a args=("${POSITIONAL[@]:2}")

    while [[ ${#args[@]} -gt 0 ]]; do
        case "${args[0]}" in
            -e|--env-id|--environment|--environment-name|--environmentName)
                require_option_value "${args[0]}" "${args[1]-}"
                env_name="${args[1]}"
                has_env=true
                args=("${args[@]:2}")
                ;;
            -i|--id)
                require_option_value "${args[0]}" "${args[1]-}"
                target_id="${args[1]}"
                selector_args+=(--id "$target_id")
                pass_args+=(--id "$target_id")
                args=("${args[@]:2}")
                ;;
            -n|--name|--copilot-name)
                require_option_value "${args[0]}" "${args[1]-}"
                target_name="${args[1]}"
                selector_args+=(--name "$target_name")
                pass_args+=(--name "$target_name")
                args=("${args[@]:2}")
                ;;
            --schema)
                require_option_value "${args[0]}" "${args[1]-}"
                schema_arg="${args[1]}"
                args=("${args[@]:2}")
                ;;
            --from-backup|--from-backup-dir)
                require_option_value "${args[0]}" "${args[1]-}"
                backup_dir="${args[1]}"
                args=("${args[@]:2}")
                ;;
            --confirm)
                require_option_value "${args[0]}" "${args[1]-}"
                confirm_value="${args[1]}"
                args=("${args[@]:2}")
                ;;
            --as-admin|--asAdmin)
                pass_args+=(--asAdmin)
                args=("${args[@]:1}")
                ;;
            --yes-really-delete)
                remove_confirmed=true
                args=("${args[@]:1}")
                ;;
            --help|-h)
                help_copilot
                return
                ;;
            *)
                pass_args+=("${args[0]}")
                args=("${args[@]:1}")
                ;;
        esac
    done

    if [[ "$has_env" == false ]]; then
        env_name=$(resolve_env_name)
    fi
    if [[ -z "$env_name" ]]; then
        echo "error: environment not set. Use --env-id <id> or --profile <name> with environmentId." >&2
        exit 1
    fi

    # Resolve profile + Dataverse URL for list/get/remove (all use Dataverse now)
    local profile dv_url
    profile=$(resolve_profile)
    export PISTUDIO_ACTIVE_PROFILE="${profile:-default}"
    PISTUDIO_PROFILE_TENANT_ID="$(read_profile_field "${profile:-default}" "tenantId" 2>/dev/null || true)"
    export PISTUDIO_PROFILE_TENANT_ID
    dv_url=""
    if [[ -n "$profile" ]]; then
        dv_url=$(read_profile_field "$profile" "dataverseUrl" || true)
    fi

    case "$subcommand" in
        list)
            if [[ -z "$dv_url" ]]; then
                echo "error: profile '$profile' is missing 'dataverseUrl' for copilot list" >&2
                exit 1
            fi
            require_jq
            local token result http_code
            token=$(get_access_token "$dv_url") || true
            if [[ -z "$token" ]]; then
                echo "error: could not get Dataverse token. Run 'pistudio login -p ${profile:-default}'." >&2
                exit 1
            fi
            result=$(curl -s -w '\n%{http_code}' "${dv_url}/api/data/v9.2/bots?\$select=botid,name,schemaname,statecode,statuscode,createdon,modifiedon" \
                -H "Authorization: Bearer $token" \
                -H "OData-MaxVersion: 4.0" \
                -H "Accept: application/json")
            http_code=$(echo "$result" | tail -1)
            result=$(echo "$result" | sed '$d')
            if [[ "$http_code" != "200" ]]; then
                echo "error: Dataverse returned HTTP $http_code" >&2
                echo "$result" | jq -r '.error.message // .Message // .' >&2 2>/dev/null || echo "$result" >&2
                exit 1
            fi
            echo "$result" | jq '.value'
            ;;
        get)
            if [[ -z "$target_id" && -z "$target_name" ]]; then
                echo "error: copilot get requires --id <id> or --name <name>" >&2
                exit 1
            fi
            if [[ -z "$dv_url" ]]; then
                echo "error: profile '$profile' is missing 'dataverseUrl' for copilot get" >&2
                exit 1
            fi
            require_jq
            local token result http_code
            token=$(get_access_token "$dv_url") || true
            if [[ -z "$token" ]]; then
                echo "error: could not get Dataverse token. Run 'pistudio login -p ${profile:-default}'." >&2
                exit 1
            fi
            if [[ -n "$target_id" ]]; then
                result=$(curl -s -w '\n%{http_code}' "${dv_url}/api/data/v9.2/bots(${target_id})" \
                    -H "Authorization: Bearer $token" \
                    -H "OData-MaxVersion: 4.0" \
                    -H "Accept: application/json")
            else
                result=$(curl -s -w '\n%{http_code}' "${dv_url}/api/data/v9.2/bots?\$filter=name%20eq%20'$(printf '%s' "$target_name" | jq -sRr @uri)'" \
                    -H "Authorization: Bearer $token" \
                    -H "OData-MaxVersion: 4.0" \
                    -H "Accept: application/json")
            fi
            http_code=$(echo "$result" | tail -1)
            result=$(echo "$result" | sed '$d')
            if [[ "$http_code" != "200" ]]; then
                echo "error: Dataverse returned HTTP $http_code" >&2
                echo "$result" | jq -r '.error.message // .Message // .' >&2 2>/dev/null || echo "$result" >&2
                exit 1
            fi
            # Unwrap single result from value array
            if echo "$result" | jq -e '.value' >/dev/null 2>&1; then
                result=$(echo "$result" | jq '.value[0] // empty')
            fi
            echo "$result" | jq '.'
            ;;
        create)
            require_write_allowed "copilot create"
            local profile dv_url schema name
            profile=$(resolve_profile)
            require_profile_dataverse_url "$profile"
            dv_url=$(read_profile_field "$profile" "dataverseUrl")

            name="$target_name"
            if [[ -z "$name" ]]; then
                echo "error: copilot create requires --name <name>" >&2
                exit 1
            fi
            schema="$schema_arg"
            if [[ -z "$schema" ]]; then
                schema=$(derive_schema_from_name "$name" || true)
            fi
            if [[ -z "$schema" ]]; then
                echo "error: could not derive schema from name. Provide --schema <schema>." >&2
                exit 1
            fi

            if [[ "$DRY_RUN" == true ]]; then
                echo "Would create copilot:"
                echo "  name:   $name"
                echo "  schema: $schema"
                echo "  dv:     $dv_url"
                return 0
            fi

            echo -e "${CYAN}Creating copilot '${name}' (${schema})...${NC}"
            local existing
            existing=$(dataverse_get_bot_by_schema "$dv_url" "$schema" | jq -r '.value[0].botid // empty')
            if [[ -n "$existing" ]]; then
                echo "error: copilot schema '$schema' already exists (botid: $existing)" >&2
                exit 1
            fi

            if ! dataverse_create_bot "$dv_url" "$name" "$schema"; then
                audit_log "copilot.create" 1 "pistudio copilot create --name \"$name\" --schema \"$schema\" -p $profile"
                exit 1
            fi

            local bot_id
            bot_id=$(dataverse_get_bot_by_schema "$dv_url" "$schema" | jq -r '.value[0].botid // empty')
            if [[ -z "$bot_id" ]]; then
                echo "error: created copilot but could not retrieve bot id" >&2
                audit_log "copilot.create" 1 "pistudio copilot create --name \"$name\" --schema \"$schema\" -p $profile"
                exit 1
            fi

            dataverse_call_bot_action "$dv_url" "$bot_id" "PvaProvision" || true
            dataverse_call_bot_action "$dv_url" "$bot_id" "PvaPublish" || true

            echo "Created:"
            echo "  name:   $name"
            echo "  schema: $schema"
            echo "  botid:  $bot_id"

            audit_log "copilot.create" 0 "pistudio copilot create --name \"$name\" --schema \"$schema\" -p $profile"
            ;;
        restore)
            require_write_allowed "copilot restore"
            local profile dv_url schema name src_dir
            profile=$(resolve_profile)
            require_profile_dataverse_url "$profile"
            dv_url=$(read_profile_field "$profile" "dataverseUrl")

            src_dir="$backup_dir"
            if [[ -z "$src_dir" ]]; then
                echo "error: copilot restore requires --from-backup <dir>" >&2
                exit 1
            fi
            if [[ ! -d "$src_dir" ]]; then
                echo "error: backup dir not found: $src_dir" >&2
                exit 1
            fi

            name="$target_name"
            if [[ -z "$name" ]]; then
                echo "error: copilot restore requires --name <name>" >&2
                exit 1
            fi
            schema="$schema_arg"
            if [[ -z "$schema" ]]; then
                schema=$(derive_schema_from_name "$name" || true)
            fi
            if [[ -z "$schema" ]]; then
                echo "error: could not derive schema from name. Provide --schema <schema>." >&2
                exit 1
            fi

            if [[ "$DRY_RUN" == true ]]; then
                echo "Would restore copilot:"
                echo "  name:   $name"
                echo "  schema: $schema"
                echo "  from:   $src_dir"
                echo "  dv:     $dv_url"
                echo "scripts/export-activities.sh --restore --backup-dir \"$src_dir\" -b \"$schema\" --profile \"$profile\""
                return 0
            fi

            echo -e "${CYAN}Restoring copilot '${name}' (${schema}) from ${src_dir}...${NC}"
            local bot_id
            bot_id=$(dataverse_get_bot_by_schema "$dv_url" "$schema" | jq -r '.value[0].botid // empty')
            if [[ -z "$bot_id" ]]; then
                echo -e "${YELLOW}Bot not found, creating shell...${NC}"
                dataverse_create_bot "$dv_url" "$name" "$schema"
                bot_id=$(dataverse_get_bot_by_schema "$dv_url" "$schema" | jq -r '.value[0].botid // empty')
            fi
            if [[ -z "$bot_id" ]]; then
                echo "error: could not create/find target copilot" >&2
                audit_log "copilot.restore" 1 "pistudio copilot restore --from-backup \"$src_dir\" --name \"$name\" --schema \"$schema\" -p $profile"
                exit 1
            fi

            "$EXPORT_SCRIPT" --restore --backup-dir "$src_dir" -b "$schema" --profile "$profile"
            local rc=$?
            if [[ $rc -ne 0 ]]; then
                audit_log "copilot.restore" "$rc" "pistudio copilot restore --from-backup \"$src_dir\" --name \"$name\" --schema \"$schema\" -p $profile"
                exit $rc
            fi

            dataverse_call_bot_action "$dv_url" "$bot_id" "PvaProvision" || true
            dataverse_call_bot_action "$dv_url" "$bot_id" "PvaPublish" || true

            echo "Restored:"
            echo "  name:   $name"
            echo "  schema: $schema"
            echo "  botid:  $bot_id"

            audit_log "copilot.restore" 0 "pistudio copilot restore --from-backup \"$src_dir\" --name \"$name\" --schema \"$schema\" -p $profile"
            ;;
        remove)
            if [[ -z "$target_id" && -z "$target_name" ]]; then
                echo "error: copilot remove requires --id <id> or --name <name>" >&2
                exit 1
            fi
            if [[ "$remove_confirmed" == false ]]; then
                echo "error: copilot remove is destructive and requires --yes-really-delete" >&2
                exit 1
            fi
            if [[ -z "$confirm_value" ]]; then
                echo "error: copilot remove requires --confirm <exact name|id>" >&2
                exit 1
            fi

            require_write_allowed "copilot remove"
            require_profile_dataverse_url "$profile"
            dv_url=$(read_profile_field "$profile" "dataverseUrl")

            # In --dry-run mode we can't resolve canonical name/id safely. Require confirm matches the provided selector.
            if [[ "$DRY_RUN" == true ]]; then
                if [[ "$confirm_value" != "$target_name" && "$confirm_value" != "$target_id" ]]; then
                    echo "error: --confirm must exactly match the provided --name or --id in --dry-run mode" >&2
                    exit 1
                fi
                local ts safe
                ts=$(date -u +"%Y%m%d_%H%M%S")
                safe=$(safe_fs_component "${target_name:-$target_id}")
                echo "Would backup to: ./backups/copilot_${safe}_${ts}"
                echo "Would run: $EXPORT_SCRIPT --backup --backup-dir ./backups/copilot_${safe}_${ts}/agents -b <resolved schemaName> --profile $profile"
                echo "Would delete bot via Dataverse DELETE bots({botid})"
                return 0
            fi

            # Resolve canonical details via Dataverse
            require_jq
            local details token
            token=$(get_access_token "$dv_url") || { echo "error: could not get Dataverse token" >&2; exit 1; }

            if [[ -n "$target_id" ]]; then
                details=$(curl -s "${dv_url}/api/data/v9.2/bots(${target_id})" \
                    -H "Authorization: Bearer $token" \
                    -H "OData-MaxVersion: 4.0" \
                    -H "Accept: application/json")
            elif [[ -n "$target_name" ]]; then
                details=$(curl -s "${dv_url}/api/data/v9.2/bots?\$filter=name%20eq%20'$(printf '%s' "$target_name" | jq -sRr @uri)'" \
                    -H "Authorization: Bearer $token" \
                    -H "OData-MaxVersion: 4.0" \
                    -H "Accept: application/json")
                if echo "$details" | jq -e '.value' >/dev/null 2>&1; then
                    details=$(echo "$details" | jq '.value[0] // empty')
                fi
            fi

            if ! echo "$details" | jq -e 'type=="object"' >/dev/null 2>&1; then
                echo "error: failed to resolve copilot details via Dataverse" >&2
                audit_log "copilot.remove" 1 "pistudio copilot remove -p $profile" ""
                exit 1
            fi

            local actual_name actual_id actual_schema
            actual_name=$(echo "$details" | jq -r '.name // empty')
            actual_id=$(echo "$details" | jq -r '.botid // empty')
            actual_schema=$(echo "$details" | jq -r '.schemaname // empty')

            if [[ -z "$actual_schema" ]]; then
                echo "error: resolved details missing schemaname; cannot backup safely" >&2
                audit_log "copilot.remove" 1 "pistudio copilot remove -p $profile" ""
                exit 1
            fi

            if [[ "$confirm_value" != "$actual_name" && "$confirm_value" != "$actual_id" ]]; then
                echo "error: confirmation mismatch. --confirm must match copilot name ('$actual_name') or id ('$actual_id')." >&2
                audit_log "copilot.remove" 1 "pistudio copilot remove -p $profile" ""
                exit 1
            fi

            local ts safe bdir
            ts=$(date -u +"%Y%m%d_%H%M%S")
            safe=$(safe_fs_component "$actual_schema")
            bdir="./backups/copilot_${safe}_${ts}"
            mkdir -p "$bdir"
            echo "$details" | jq '.' > "${bdir}/copilot.get.json"

            # Auto-backup agents. Fail closed if backup fails.
            "$EXPORT_SCRIPT" --backup --backup-dir "${bdir}/agents" -b "$actual_schema" --profile "$profile"
            local backup_rc=$?
            if [[ $backup_rc -ne 0 ]]; then
                echo "error: backup failed; refusing to delete" >&2
                audit_log "copilot.remove" "$backup_rc" "pistudio copilot remove --name \"$actual_name\" -p $profile" "$bdir"
                exit $backup_rc
            fi

            # Delete via Dataverse
            local del_code
            del_code=$(curl -s -o /tmp/pistudio_delete_bot.json -w "%{http_code}" -X DELETE "${dv_url}/api/data/v9.2/bots(${actual_id})" \
                -H "Authorization: Bearer $token" \
                -H "OData-MaxVersion: 4.0" \
                -H "Accept: application/json")
            local rc=0
            if [[ "$del_code" != "204" ]]; then
                echo "error: Dataverse DELETE returned HTTP $del_code" >&2
                cat /tmp/pistudio_delete_bot.json >&2 2>/dev/null || true
                rc=1
            fi
            audit_log "copilot.remove" "$rc" "pistudio copilot remove --name \"$actual_name\" -p $profile" "$bdir"
            return $rc
            ;;
        *)
            suggest_verb copilot "$subcommand"
            ;;
    esac
}

# ─── Subcommand routers ────────────────────────────────────────

cmd_envs() {
    local verb="${1:-}"
    case "$verb" in
        ""|list)
            run --list-envs "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        details)
            local env_id="${2:?'env-id required: pistudio envs details <env-id>'}"
            run --env-details --env-id "$env_id" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        flags)
            local env_id="${2:?'env-id required: pistudio envs flags <env-id>'}"
            run --feature-flags --env-id "$env_id" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        --help|-h)
            help_envs
            ;;
        *)
            suggest_verb envs "$verb"
            ;;
    esac
}

cmd_bots() {
    local verb="${1:-}"
    case "$verb" in
        ""|list)
            run --list-bots "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        --help|-h)
            help_bots
            ;;
        *)
            # Could be trailing flags already consumed, just list
            suggest_verb bots "$verb"
            ;;
    esac
}

cmd_agents() {
    local verb="${1:-}"
    shift 2>/dev/null || true
    local -a rest=("${POSITIONAL[@]:2}")

    case "$verb" in
        ""|list)
            run --list-subagents "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        get)
            local target="${POSITIONAL[2]:?'agent name/schema required: pistudio agents get <name>'}"
            run --export-agent --agent-schema "$target" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        create)
            require_write_allowed "agents create"
            local name="${POSITIONAL[2]:?'agent name required: pistudio agents create <name>'}"
            local -a extra_args=()
            # Collect remaining positional args as passthrough (--yaml-file etc.)
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                extra_args+=("${POSITIONAL[$i]}")
            done
            run --create-agent --agent-name "$name" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            local rc=$?
            audit_log "agents.create" "$rc" "pistudio ${POSITIONAL[*]}"
            return $rc
            ;;
        update)
            require_write_allowed "agents update"
            local schema="${POSITIONAL[2]:?'agent schema required: pistudio agents update <schema>'}"
            local -a extra_args=()
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                extra_args+=("${POSITIONAL[$i]}")
            done
            run --update-agent --agent-schema "$schema" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            local rc=$?
            audit_log "agents.update" "$rc" "pistudio ${POSITIONAL[*]}"
            return $rc
            ;;
        delete)
            local schema="${POSITIONAL[2]:?'agent schema required: pistudio agents delete <schema>'}"

            local confirmed=false
            local confirm_value=""
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                case "${POSITIONAL[$i]}" in
                    --yes-really-delete)
                        confirmed=true
                        ;;
                    --confirm)
                        confirm_value="${POSITIONAL[$((i+1))]:-}"
                        (( i++ ))
                        ;;
                esac
            done

            if [[ "$confirmed" == false ]]; then
                echo "error: agents delete is destructive and requires --yes-really-delete" >&2
                exit 1
            fi
            if [[ -z "$confirm_value" ]]; then
                echo "error: agents delete requires --confirm <exact name|schema>" >&2
                exit 1
            fi

            require_write_allowed "agents delete"
            local profile dv_url
            profile=$(resolve_profile)
            require_profile_dataverse_url "$profile"
            dv_url=$(read_profile_field "$profile" "dataverseUrl")

            if [[ "$DRY_RUN" == true ]]; then
                if [[ "$confirm_value" != "$schema" ]]; then
                    echo "error: --confirm must exactly match schema in --dry-run mode" >&2
                    exit 1
                fi
                local ts safe bdir
                ts=$(date -u +"%Y%m%d_%H%M%S")
                safe=$(safe_fs_component "$schema")
                bdir="./backups/agent_${safe}_${ts}"
                echo "Would backup to: $bdir"
                echo "Would delete agent schema: $schema"
                return 0
            fi

            local agent_json
            agent_json=$(dataverse_get_botcomponent_by_schema "$dv_url" "$schema")
            if ! echo "$agent_json" | jq -e '.value | length > 0' >/dev/null 2>&1; then
                echo "error: agent not found: $schema" >&2
                audit_log "agents.delete" 1 "pistudio ${POSITIONAL[*]}"
                exit 1
            fi

            local actual_name component_id data desc
            actual_name=$(echo "$agent_json" | jq -r '.value[0].name // empty')
            component_id=$(echo "$agent_json" | jq -r '.value[0].botcomponentid // empty')
            data=$(echo "$agent_json" | jq -r '.value[0].data // empty')
            desc=$(echo "$agent_json" | jq -r '.value[0].description // empty')

            if [[ -z "$component_id" ]]; then
                echo "error: could not resolve botcomponentid for $schema" >&2
                audit_log "agents.delete" 1 "pistudio ${POSITIONAL[*]}"
                exit 1
            fi

            if [[ "$confirm_value" != "$schema" && "$confirm_value" != "$actual_name" ]]; then
                echo "error: confirmation mismatch. --confirm must match agent name ('$actual_name') or schema ('$schema')." >&2
                audit_log "agents.delete" 1 "pistudio ${POSITIONAL[*]}"
                exit 1
            fi

            local ts safe bdir
            ts=$(date -u +"%Y%m%d_%H%M%S")
            safe=$(safe_fs_component "$schema")
            bdir="./backups/agent_${safe}_${ts}"
            mkdir -p "$bdir"
            echo "$agent_json" | jq '.' > "${bdir}/agent.full.json"
            if [[ -n "$data" ]]; then
                printf "%s\n" "$data" > "${bdir}/agent.yaml"
            fi
            jq -n --arg name "$actual_name" --arg schema "$schema" --arg id "$component_id" --arg desc "$desc" --arg exportedAt "$(now_iso_utc)" \
                '{name:$name, schemaname:$schema, botcomponentid:$id, description:$desc, exportedAt:$exportedAt}' > "${bdir}/agent.meta.json"

            if ! dataverse_delete_botcomponent_by_id "$dv_url" "$component_id"; then
                audit_log "agents.delete" 1 "pistudio ${POSITIONAL[*]}" "$bdir"
                exit 1
            fi

            audit_log "agents.delete" 0 "pistudio ${POSITIONAL[*]}" "$bdir"
            echo "Deleted agent: $actual_name ($schema)"
            ;;
        clone)
            require_write_allowed "agents clone"
            local schema="${POSITIONAL[2]:?'source schema required: pistudio agents clone <schema>'}"
            local -a extra_args=()
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                case "${POSITIONAL[$i]}" in
                    --name)
                        extra_args+=(--new-name "${POSITIONAL[$((i+1))]}")
                        (( i++ ))
                        ;;
                    *)
                        extra_args+=("${POSITIONAL[$i]}")
                        ;;
                esac
            done
            run --clone --source-agent "$schema" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            local rc=$?
            audit_log "agents.clone" "$rc" "pistudio ${POSITIONAL[*]}"
            return $rc
            ;;
        diff)
            local a="${POSITIONAL[2]:?'first agent required: pistudio agents diff <a> <b>'}"
            local b="${POSITIONAL[3]:?'second agent required: pistudio agents diff <a> <b>'}"
            run --diff --agent1 "$a" --agent2 "$b" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        backup)
            run --backup "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        restore)
            require_write_allowed "agents restore"
            local -a extra_args=()
            for (( i=2; i<${#POSITIONAL[@]}; i++ )); do
                case "${POSITIONAL[$i]}" in
                    --dir)
                        extra_args+=(--backup-dir "${POSITIONAL[$((i+1))]}")
                        (( i++ ))
                        ;;
                    *)
                        extra_args+=("${POSITIONAL[$i]}")
                        ;;
                esac
            done
            run --restore "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            local rc=$?
            audit_log "agents.restore" "$rc" "pistudio ${POSITIONAL[*]}"
            return $rc
            ;;
        --help|-h)
            help_agents
            ;;
        *)
            suggest_verb agents "$verb"
            ;;
    esac
}

cmd_convs() {
    local verb="${1:-}"

    case "$verb" in
        ""|list)
            run --list-conversations "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        export)
            local target="${POSITIONAL[2]:-}"
            if [[ -z "$target" ]]; then
                # Check for --all in remaining positional args
                local has_all=false
                for arg in "${POSITIONAL[@]:2}"; do
                    [[ "$arg" == "--all" ]] && has_all=true
                done
                if [[ "$has_all" == true ]]; then
                    local -a extra_args=()
                    for (( i=2; i<${#POSITIONAL[@]}; i++ )); do
                        case "${POSITIONAL[$i]}" in
                            --all) ;; # consumed
                            --file)
                                extra_args+=(--conversations-file "${POSITIONAL[$((i+1))]}")
                                (( i++ ))
                                ;;
                            *)
                                extra_args+=("${POSITIONAL[$i]}")
                                ;;
                        esac
                    done
                    run --export-all "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
                else
                    echo "error: conversation id required: pistudio convs export <id>" >&2
                    exit 1
                fi
            elif [[ "$target" == "--all" ]]; then
                local -a extra_args=()
                for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                    case "${POSITIONAL[$i]}" in
                        --file)
                            extra_args+=(--conversations-file "${POSITIONAL[$((i+1))]}")
                            (( i++ ))
                            ;;
                        *)
                            extra_args+=("${POSITIONAL[$i]}")
                            ;;
                    esac
                done
                run --export-all "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            else
                local -a extra_args=()
                for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                    extra_args+=("${POSITIONAL[$i]}")
                done
                run -c "$target" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            fi
            ;;
        search)
            local term="${POSITIONAL[2]:?'search term required: pistudio convs search <term>'}"
            local -a extra_args=()
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                extra_args+=("${POSITIONAL[$i]}")
            done
            run --search "$term" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        watch)
            local target="${POSITIONAL[2]:?'conversation id required: pistudio convs watch <id>'}"
            local -a extra_args=()
            for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                extra_args+=("${POSITIONAL[$i]}")
            done
            run --watch -c "$target" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        --help|-h)
            help_convs
            ;;
        *)
            suggest_verb convs "$verb"
            ;;
    esac
}

cmd_transcripts() {
    local verb="${1:-}"

    case "$verb" in
        ""|list)
            run --list-transcripts "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            ;;
        export)
            local target="${POSITIONAL[2]:-}"
            if [[ -z "$target" ]]; then
                # Check for --bot-guid in remaining args
                local -a extra_args=()
                for (( i=2; i<${#POSITIONAL[@]}; i++ )); do
                    extra_args+=("${POSITIONAL[$i]}")
                done
                if [[ ${#extra_args[@]} -gt 0 ]]; then
                    run --from-dataverse "${extra_args[@]}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
                else
                    echo "error: transcript id or --bot-guid required" >&2
                    exit 1
                fi
            elif [[ "$target" == --* ]]; then
                # Flags like --bot-guid passed directly
                local -a extra_args=()
                for (( i=2; i<${#POSITIONAL[@]}; i++ )); do
                    extra_args+=("${POSITIONAL[$i]}")
                done
                run --from-dataverse "${extra_args[@]}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            else
                local -a extra_args=()
                for (( i=3; i<${#POSITIONAL[@]}; i++ )); do
                    extra_args+=("${POSITIONAL[$i]}")
                done
                run --from-dataverse --transcript-id "$target" "${extra_args[@]+"${extra_args[@]}"}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
            fi
            ;;
        --help|-h)
            help_transcripts
            ;;
        *)
            suggest_verb transcripts "$verb"
            ;;
    esac
}

cmd_open() {
    local url="${1:-}"
    if [[ -n "$url" && "$url" != --* ]]; then
        run --open --url "$url" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
    else
        run --open "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
    fi
}

cmd_analytics() {
    local dir="${1:?'directory required: pistudio analytics <dir>'}"
    run --analytics-only -o "$dir" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
}

# ─── Top-level verb shortcuts ──────────────────────────────────

shortcut_export() {
    local id="${1:?'conversation id required: pistudio export <id>'}"
    shift
    run -c "$id" "$@" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
}

shortcut_search() {
    local term="${1:?'search term required: pistudio search <term>'}"
    shift
    run --search "$term" "$@" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
}

shortcut_watch() {
    local id="${1:?'conversation id required: pistudio watch <id>'}"
    shift
    run --watch -c "$id" "$@" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
}

# ─── Main dispatch ─────────────────────────────────────────────

main() {
    # No arguments → brief help
    if [[ $# -eq 0 ]]; then
        help_brief
        exit 0
    fi

    # Extract globals (--dry-run, -p, -v, -b, -d, -o) from all args
    extract_globals "$@"

    # Nothing left after globals? Show help
    if [[ ${#POSITIONAL[@]} -eq 0 ]]; then
        help_brief
        exit 0
    fi

    local command="${POSITIONAL[0]}"

    # Passthrough: any leading --flag goes straight to export-activities.sh
    if [[ "$command" == -* ]]; then
        # --help at top level → full reference
        if [[ "$command" == "--help" || "$command" == "-h" ]]; then
            if [[ "$DRY_RUN" == true ]]; then
                echo "scripts/export-activities.sh --help"
            else
                exec "$EXPORT_SCRIPT" --help
            fi
            exit 0
        fi
        run "${POSITIONAL[@]}" "${GLOBAL_ARGS[@]+"${GLOBAL_ARGS[@]}"}"
        exit 0
    fi

    # Subcommand dispatch
    case "$command" in
        login)
            cmd_login
            ;;
        logout)
            cmd_logout
            ;;
        status)
            cmd_status
            ;;
        doctor)
            cmd_doctor
            ;;
        envs)
            cmd_envs "${POSITIONAL[1]:-}" "${POSITIONAL[@]:2}"
            ;;
        copilot|copilots)
            cmd_copilot "${POSITIONAL[1]:-}"
            ;;
        bots)
            cmd_bots "${POSITIONAL[1]:-}"
            ;;
        agents)
            cmd_agents "${POSITIONAL[1]:-}"
            ;;
        convs|conversations)
            cmd_convs "${POSITIONAL[1]:-}"
            ;;
        transcripts)
            cmd_transcripts "${POSITIONAL[1]:-}"
            ;;
        open)
            cmd_open "${POSITIONAL[1]:-}"
            ;;
        analytics)
            cmd_analytics "${POSITIONAL[1]:-}"
            ;;
        # Top-level verb shortcuts
        export)
            shortcut_export "${POSITIONAL[@]:1}"
            ;;
        search)
            shortcut_search "${POSITIONAL[@]:1}"
            ;;
        watch)
            shortcut_watch "${POSITIONAL[@]:1}"
            ;;
        # Unknown → fuzzy match
        *)
            unknown_command "$command"
            ;;
    esac
}

main "$@"
